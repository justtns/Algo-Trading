# Trading System Project Guide

This document is the technical reference for the entire repository:

- What each module does
- How data and orders move through the system
- How trades are executed in backtest and live trading
- How to add and ship a new strategy safely

## 1. Project Overview

This repository is a NautilusTrader-based trading system with:

- Backtesting via `BacktestEngine`
- Live trading via `TradingNode`
- Native IBKR integration
- Custom MetaTrader 5 integration
- Strategy implementations for FX/equities
- Capital allocation, persistence, and performance tooling

Core package: `trader/`  
Historical data helpers: `historical_data_services/`

## 2. Repository Map

### Root-level paths

- `trader/`: main application code
- `historical_data_services/`: standalone data fetchers (IBKR, Polygon)
- `config/`: portfolio and contract configuration
- `docs/`: documentation
- `tests/`: unit and integration tests
- `data/`: local parquet datasets
- `saved_data/`: local data store output

### `trader/` modules

- `trader/core/`: venues, enums, instruments, event dataclasses
- `trader/config/`: builders and orchestration (`BacktestEngine`, `TradingNode`, YAML orchestrator)
- `trader/adapters/`: broker adapters
- `trader/data/`: ingestion, normalization, bar building, quality checks, retry
- `trader/strategy/`: strategy configs, strategy classes, signal logic, helpers
- `trader/capital/`: capital allocation (including risk parity)
- `trader/exec/`: risk manager utilities
- `trader/portfolio/`: position store, equity tracker, PnL metrics, charts
- `trader/persistence/`: SQLite schema and repositories
- `trader/interfaces/`: HTTP and Telegram placeholders

## 3. Runtime Modes

### Backtest mode

Main path:

1. Build instruments (`trader.core.instruments`)
2. Load/normalize data (`trader.data.pipeline`, `trader.data.catalog`)
3. Build strategy instances (`trader.strategy.*`)
4. Build engine (`trader.config.node.build_backtest_engine` or `build_multi_venue_backtest_engine`)
5. Run engine and inspect results

### Live mode

Main path:

1. Build data and execution client configs (IBKR or MT5)
2. Build `TradingNode` (`trader.config.live_node.build_live_trading_node` or direct `TradingNode`)
3. Register client factories for MT5
4. Add strategies
5. Start node, subscribe to bars, route orders to venue clients

## 4. How Trades Are Executed

This is the actual order lifecycle used by strategy classes in `trader/strategy/`.

### 4.1 Signal to order object

On each bar (`on_bar`), strategy logic decides whether to:

- Enter a position
- Close/flip a position
- Place protective stops

Orders are created with `order_factory`, typically:

- `order_factory.market(...)`
- `order_factory.stop_market(...)`

### 4.2 Strategy routing to execution client

Strategies using `LiveExecutionMixin` call `_submit_order(...)`, which:

- Uses default routing if `exec_client_id` is not set
- Routes to a specific client if `exec_client_id` is configured

This supports multi-venue/multi-client nodes without strategy-side broker code.

### 4.3 Venue execution handling

#### Backtest

- Orders are handled by NautilusTrader simulated venue
- Fills are generated by engine simulation
- Strategy receives standard events (`on_order_filled`, `on_position_closed`)

#### IBKR live

- Uses NautilusTrader built-in IBKR adapter
- Config created via `trader.adapters.ibkr.config` helpers
- Orders go through IBKR execution client configured on `TradingNode`

#### MT5 live

`MetaTrader5ExecutionClient` (`trader/adapters/metatrader/execution.py`) handles:

- Nautilus order type -> MT5 request mapping
- Quantity -> MT5 volume conversion using instrument lot size
- Broker fill-mode compatibility fallback
- `order_send(...)` submission
- Accepted/filled/rejected event generation back into Nautilus event bus

### 4.4 Fill and position lifecycle inside strategies

Strategies track order and position state explicitly:

- Entry order IDs to prevent duplicate entries
- Pending close position IDs to avoid duplicate close orders
- Stop-order IDs for cancel/replace logic

On events, they clear or update state:

- `on_order_filled`: mark entry complete, optionally place stop
- `on_order_rejected` / `on_order_denied` / `on_order_canceled` / `on_order_expired`: release pending state
- `on_position_closed`: clear close-tracking and log realized PnL

This pattern is implemented in all live-ready strategies (`Gotobi`, `Breakout`, `MeanReversion`, `RsiMacdMa`, `OneMinuteBuyHold`).

## 5. Capital Allocation and Trade Sizing

Two sizing layers exist:

1. Allocation layer (`trader.capital.allocator`)
2. Strategy quantity resolution (`trader.strategy.live_helpers.resolve_trade_quantity`)

### 5.1 Allocation formulas

- Margin-based:
  - `trade_size = allocated_capital / (margin_rate * contract_size * safety_factor)`
- Capital-based:
  - `trade_size = floor(allocated_capital / reference_price)`

### 5.2 YAML-driven orchestration

`TradingOrchestrator.from_yaml("config/portfolio.yaml")`:

- Loads strategy specs
- Allocates capital
- Injects `trade_size` into each strategy config

### 5.3 Strategy quantity conversion

At runtime, strategy quantity is resolved using the instrument definition:

- If `allocated_capital` is set: `allocated_capital / margin_rate`
- Else: `configured_trade_size * instrument.lot_size`

Because quantity precision and lot sizes come from instruments, instrument metadata must be loaded correctly before strategy start.

## 6. Existing Strategies

- `GotobiStrategy`: time-based entry/exit on Japanese settlement dates
- `GotobiWithSLStrategy`: Gotobi + stop-market protection
- `MeanReversionStrategy`: MA deviation mean-reversion entry and signal-flip exits
- `BreakoutStrategy`: 50-bar breakout entry and signal-flip exits
- `RsiMacdMaStrategy`: RSI + MACD histogram curl + MA confirmation, optional neutral exit/time exit/stops
- `OneMinuteBuyHoldStrategy`: simple buy-hold-exit loop for connectivity/smoke tests

## 7. Build a New Strategy

Use this as the default implementation workflow.

### Step 1: Create strategy config + class

Create `trader/strategy/my_strategy.py`:

```python
from __future__ import annotations

import pandas as pd
from nautilus_trader.config import StrategyConfig
from nautilus_trader.model.data import Bar, BarType
from nautilus_trader.model.enums import OrderSide, TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.objects import Quantity
from nautilus_trader.trading.strategy import Strategy

from trader.strategy.live_helpers import LiveExecutionMixin, resolve_trade_quantity


class MyStrategyConfig(StrategyConfig, frozen=True):
    instrument_id: str
    bar_type: str
    trade_size: float = 1.0
    max_bars: int = 300
    time_in_force: str = "FOK"
    exec_client_id: str | None = None


class MyStrategy(LiveExecutionMixin, Strategy):
    def __init__(self, config: MyStrategyConfig) -> None:
        super().__init__(config)
        self.instrument_id = InstrumentId.from_str(config.instrument_id)
        self.bar_type = BarType.from_str(config.bar_type)
        self.trade_size = config.trade_size
        self.trade_qty = config.trade_size
        self.max_bars = config.max_bars
        self._configure_live_execution(
            exec_client_id=config.exec_client_id,
            time_in_force=config.time_in_force,
            default_tif=TimeInForce.FOK,
        )
        self._bars: list[dict] = []
        self._entry_order_id = None
        self._pending_close_position_ids: set = set()
        self._close_order_to_position_id: dict = {}

    def on_start(self) -> None:
        self.instrument = self.cache.instrument(self.instrument_id)
        if self.instrument is None:
            self.log.error(f"Instrument {self.instrument_id} not found in cache")
            return
        self.trade_qty = resolve_trade_quantity(
            instrument=self.instrument,
            configured_trade_size=self.trade_size,
        )
        self.subscribe_bars(self.bar_type)

    def on_bar(self, bar: Bar) -> None:
        self._bars.append({"close": float(bar.close)})
        self._bars = self._bars[-self.max_bars:]
        signal = self._compute_signal(pd.DataFrame(self._bars))
        position = self._current_position()

        if signal > 0 and position is None and self._entry_order_id is None:
            order = self.order_factory.market(
                instrument_id=self.instrument_id,
                order_side=OrderSide.BUY,
                quantity=Quantity(abs(self.trade_qty), self.instrument.size_precision),
                time_in_force=self.time_in_force,
            )
            self._entry_order_id = order.client_order_id
            self._submit_order(order)

    def _compute_signal(self, bars: pd.DataFrame) -> float:
        return 1.0 if len(bars) > 20 else 0.0

    def on_order_filled(self, event) -> None:
        if self._entry_order_id is not None and event.client_order_id == self._entry_order_id:
            self._entry_order_id = None

    def on_stop(self) -> None:
        self.unsubscribe_bars(self.bar_type)
```

### Step 2: Register strategy in YAML orchestrator

Update `_ensure_registry()` in `trader/config/orchestrator.py`:

- Import your strategy and config
- Add `"MyStrategy": (MyStrategy, MyStrategyConfig)` to `_STRATEGY_REGISTRY`

Without this, `TradingOrchestrator.from_yaml(...)` cannot build it.

### Step 3: Export strategy (optional but recommended)

If you want `from trader import MyStrategy`, update `trader/__init__.py`:

- Add imports
- Add names to `__all__`

### Step 4: Add tests

At minimum:

- Signal logic tests (`tests/test_my_strategy_signal.py`)
- Lifecycle tests for order state resets and re-entry rules
- Config and routing tests if using `exec_client_id` / `time_in_force`

Run tests:

```bash
pytest -q
```

### Step 5: Add to portfolio config

Add your strategy entry in `config/portfolio.yaml`:

```yaml
- name: my_strategy
  strategy: MyStrategy
  venue: IDEALPRO
  instrument_class: margin_based
  weight: 0.2
  margin_rate: 0.02
  config:
    instrument_id: "EUR/USD.IDEALPRO"
    bar_type: "EUR/USD.IDEALPRO-1-MINUTE-MID-EXTERNAL"
```

## 8. Data Pipeline and Historical Fetching

- `trader.data.pipeline`: normalize raw data into UTC OHLCV
- `trader.data.catalog`: DataFrame -> Nautilus `Bar` conversion
- `trader.data.bar_builder`: tick -> bar aggregation (used by MT5 data client)
- `historical_data_services.ibkr_data_fetch`: IBKR historical pull (single and chunked)
- `historical_data_services.polygon_data_fetch`: Polygon historical pull (single and chunked)

## 9. Persistence and Analytics

- SQLite database layer in `trader.persistence.database`
- Repositories in `trader.persistence.repositories`
- Position/fill store with optional write-through persistence in `trader.portfolio.store`
- Equity tracking in `trader.portfolio.equity`
- Performance metrics in `trader.portfolio.pnl`
- Optional Plotly charts in `trader.portfolio.charts`

## 10. What Is Still a Placeholder

- `trader/interfaces/http_api.py`: API not implemented
- `trader/interfaces/telegram_bot.py`: bot not implemented
- `trader/exec/reconcile.py`: reconciliation scaffold only

Treat these as extension points, not production-ready components.

## 11. Recommended Dev Workflow

1. Run tests before and after strategy changes.
2. Validate strategy behavior in backtest first.
3. Smoke-test live routing with tiny sizes on demo/paper accounts.
4. Add persistence snapshots during long live tests for postmortem analysis.
5. Keep strategy logic deterministic and side-effect free except for explicit order submission.
